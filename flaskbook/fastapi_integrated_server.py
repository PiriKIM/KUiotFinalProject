from fastapi import FastAPI, Request, Response, HTTPException
from fastapi.responses import HTMLResponse, StreamingResponse, JSONResponse
from fastapi.staticfiles import StaticFiles
from fastapi.templating import Jinja2Templates
from fastapi.middleware.cors import CORSMiddleware
import uvicorn
import requests
import aiohttp
import cv2
import numpy as np
import mediapipe as mp
import json
import sqlite3
import threading
import time
import subprocess
import logging
import asyncio
import re
import math
from datetime import datetime
from typing import Optional
import os
from pydantic import BaseModel

# Î°úÍπÖ ÏÑ§Ï†ï
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

app = FastAPI(title="ESP32-CAM ÏûêÏÑ∏ Î∂ÑÏÑù ÏãúÏä§ÌÖú", version="1.0.0")

# CORS ÏÑ§Ï†ï
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Ï†ïÏ†Å ÌååÏùºÍ≥º ÌÖúÌîåÎ¶ø ÏÑ§Ï†ï
app.mount("/static", StaticFiles(directory="apps/crud/static"), name="static")
templates = Jinja2Templates(directory="apps/templates")

# ESP32 ÏÑ§Ï†ï
ESP32_IP = "192.168.0.102"
ESP32_STREAM_PORT = 81
ESP32_API_PORT = 81  # ESP32-CAMÏùÄ 81 Ìè¨Ìä∏ÏóêÏÑú Î™®Îì† ÏÑúÎπÑÏä§ Ï†úÍ≥µ
ESP32_STREAM_URL = f"http://{ESP32_IP}:{ESP32_STREAM_PORT}"
ESP32_API_URL = f"http://{ESP32_IP}:{ESP32_API_PORT}"

# ESP8266 Buzzer ÏÑ§Ï†ï
ESP8266_IP = "192.168.0.112"
ESP8266_PORT = 80
ESP8266_BUZZER_URL = f"http://{ESP8266_IP}:{ESP8266_PORT}"

# MediaPipe ÏÑ§Ï†ï
mp_pose = mp.solutions.pose
mp_drawing = mp.solutions.drawing_utils
pose = mp_pose.Pose(
    min_detection_confidence=0.5,
    min_tracking_confidence=0.5
)

# Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ï¥àÍ∏∞Ìôî
def init_db():
    conn = sqlite3.connect('local.sqlite')
    cursor = conn.cursor()
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS posture_data (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
            overall_score INTEGER,
            overall_grade TEXT,
            neck_angle REAL,
            neck_grade TEXT,
            spine_angle REAL,
            shoulder_angle REAL,
            pelvic_angle REAL,
            user_id INTEGER DEFAULT 1
        )
    ''')
    conn.commit()
    conn.close()

# ESP32 Ïó∞Í≤∞ ÌôïÏù∏
def check_esp32_connection():
    try:
        response = requests.get(f"{ESP32_API_URL}/status", timeout=2)
        return response.status_code == 200
    except:
        return False

# Ïó∞ÏÜç ÏûêÏÑ∏ Î∂ÑÏÑù Ïπ¥Ïö¥ÌÑ∞
posture_counter = {
    'A': 0,
    'B': 0, 
    'C': 0,
    'no_pose': 0
}

# Ï†ÑÏó≠ Ïä§Ìä∏Î¶º Ïó∞Í≤∞ Í¥ÄÎ¶¨
class StreamManager:
    def __init__(self):
        self.current_frame = None
        self.frame_lock = threading.Lock()
        self.stream_active = False
        self.last_frame_time = 0
        
    def update_frame(self, frame):
        with self.frame_lock:
            self.current_frame = frame.copy() if frame is not None else None
            self.last_frame_time = time.time()
    
    def get_frame(self):
        with self.frame_lock:
            if self.current_frame is not None and time.time() - self.last_frame_time < 5:  # 5Ï¥à Ïù¥ÎÇ¥ ÌîÑÎ†àÏûÑÎßå Ïú†Ìö®
                return self.current_frame.copy()
            return None
    
    def is_stream_active(self):
        return self.stream_active and (time.time() - self.last_frame_time < 10)  # 10Ï¥à Ïù¥ÎÇ¥ ÌôúÎèô ÏûàÏúºÎ©¥ ÌôúÏÑ±

# Ï†ÑÏó≠ Ïä§Ìä∏Î¶º Îß§ÎãàÏ†Ä Ïù∏Ïä§ÌÑ¥Ïä§
stream_manager = StreamManager()

# ESP8266 Buzzer Control Ìï®ÏàòÎì§
def check_esp8266_connection():
    """ESP8266 Ïó∞Í≤∞ ÏÉÅÌÉú ÌôïÏù∏"""
    try:
        response = requests.get(f"{ESP8266_BUZZER_URL}/status", timeout=2)
        return response.status_code == 200
    except:
        return False

def trigger_buzzer(duration_ms=1000, volume=50):
    """ESP8266 buzzer Ìä∏Î¶¨Í±∞ (ÎèôÍ∏∞)"""
    try:
        data = {
            "duration": duration_ms,
            "volume": volume
        }
        response = requests.post(f"{ESP8266_BUZZER_URL}/buzzer", json=data, timeout=2)
        return response.status_code == 200
    except Exception as e:
        logger.error(f"Buzzer trigger failed: {e}")
        return False

async def trigger_buzzer_async(duration_ms=1000, volume=50):
    """ESP8266 buzzer Ìä∏Î¶¨Í±∞ (ÎπÑÎèôÍ∏∞) - aiohttp ÏÇ¨Ïö©"""
    try:
        data = {
            "duration": duration_ms,
            "volume": volume
        }
        async with aiohttp.ClientSession() as session:
            async with session.post(f"{ESP8266_BUZZER_URL}/buzzer", json=data, timeout=aiohttp.ClientTimeout(total=2)) as response:
                if response.status == 200:
                    current_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                    logger.info(f"[{current_time}] üîä ÎπÑÎèôÍ∏∞ Î∂ÄÏ†Ä Ìä∏Î¶¨Í±∞ ÏÑ±Í≥µ: {duration_ms}ms, Î≥ºÎ•® {volume}%")
                    return True
                else:
                    current_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                    logger.error(f"[{current_time}] ‚ùå ÎπÑÎèôÍ∏∞ Î∂ÄÏ†Ä Ìä∏Î¶¨Í±∞ Ïã§Ìå®: {response.status}")
                    return False
    except Exception as e:
        current_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        logger.error(f"[{current_time}] ‚ùå ÎπÑÎèôÍ∏∞ Î∂ÄÏ†Ä Ìä∏Î¶¨Í±∞ Ïò§Î•ò: {e}")
        return False

def set_buzzer_volume(volume):
    """ESP8266 buzzer Î≥ºÎ•® ÏÑ§Ï†ï"""
    try:
        data = {"volume": volume}
        response = requests.post(f"{ESP8266_BUZZER_URL}/volume", json=data, timeout=2)
        return response.status_code == 200
    except Exception as e:
        logger.error(f"Buzzer volume setting failed: {e}")
        return False

def get_buzzer_status():
    """ESP8266 buzzer ÏÉÅÌÉú ÌôïÏù∏"""
    try:
        response = requests.get(f"{ESP8266_BUZZER_URL}/status", timeout=2)
        if response.status_code == 200:
            return response.json()
        return None
    except Exception as e:
        logger.error(f"Buzzer status check failed: {e}")
        return None

# FlaskÏùò PostureAnalyzer ÌÅ¥ÎûòÏä§ Í∞ÄÏ†∏Ïò§Í∏∞
class PostureAnalyzer:
    def __init__(self):
        import mediapipe as mp
        self.mp_pose = mp.solutions.pose

    def calculate_angle(self, a, b, c):
        """ÏÑ∏ Ï†êÏúºÎ°ú Í∞ÅÎèÑ Í≥ÑÏÇ∞"""
        a_pt = np.array([a.x, a.y]) if not isinstance(a, np.ndarray) else a
        b_pt = np.array([b.x, b.y]) if not isinstance(b, np.ndarray) else b
        c_pt = np.array([c.x, c.y]) if not isinstance(c, np.ndarray) else c

        ba = a_pt - b_pt
        bc = c_pt - b_pt

        cosine_angle = np.dot(ba, bc) / (np.linalg.norm(ba) * np.linalg.norm(bc))
        angle = np.arccos(np.clip(cosine_angle, -1.0, 1.0))
        return np.degrees(angle)

    def calculate_neck_angle(self, landmarks):
        """Î™© Í∞ÅÎèÑ Í≥ÑÏÇ∞"""
        mp = self.mp_pose
        try:
            if landmarks[mp.PoseLandmark.LEFT_EAR].visibility > 0.5 and landmarks[mp.PoseLandmark.LEFT_SHOULDER].visibility > 0.5:
                ear = landmarks[mp.PoseLandmark.LEFT_EAR]
                shoulder = landmarks[mp.PoseLandmark.LEFT_SHOULDER]
            elif landmarks[mp.PoseLandmark.RIGHT_EAR].visibility > 0.5 and landmarks[mp.PoseLandmark.RIGHT_SHOULDER].visibility > 0.5:
                ear = landmarks[mp.PoseLandmark.RIGHT_EAR]
                shoulder = landmarks[mp.PoseLandmark.RIGHT_SHOULDER]
            else:
                left_ear = landmarks[mp.PoseLandmark.LEFT_EAR]
                right_ear = landmarks[mp.PoseLandmark.RIGHT_EAR]
                left_shoulder = landmarks[mp.PoseLandmark.LEFT_SHOULDER]
                right_shoulder = landmarks[mp.PoseLandmark.RIGHT_SHOULDER]
                ear = np.array([(left_ear.x + right_ear.x) / 2, (left_ear.y + right_ear.y) / 2])
                shoulder = np.array([(left_shoulder.x + right_shoulder.x) / 2, (left_shoulder.y + right_shoulder.y) / 2])

            if hasattr(ear, 'x'):
                vertical = np.array([shoulder.x, ear.y])
            else:
                vertical = np.array([shoulder[0], ear[1]])
            return self.calculate_angle(ear, shoulder, vertical)
        except:
            return None

    def grade_neck_posture(self, neck_angle):
        if neck_angle <= 5:
            return 'A', "ÏôÑÎ≤ΩÌïú ÏûêÏÑ∏"
        elif neck_angle <= 10:
            return 'B', "ÏñëÌò∏Ìïú ÏûêÏÑ∏"
        elif neck_angle <= 15:
            return 'C', "Î≥¥ÌÜµ ÏûêÏÑ∏"
        else:
            return 'D', "ÎÇòÏÅú ÏûêÏÑ∏"

    def analyze_turtle_neck_detailed(self, landmarks):
        """Í±∞Î∂ÅÎ™© ÏÉÅÏÑ∏ Î∂ÑÏÑù"""
        mp = self.mp_pose
        neck_angle = self.calculate_neck_angle(landmarks)
        grade, desc = self.grade_neck_posture(neck_angle)
        neck_top = (
            (landmarks[mp.PoseLandmark.LEFT_EAR].x + landmarks[mp.PoseLandmark.RIGHT_EAR].x) / 2,
            (landmarks[mp.PoseLandmark.LEFT_EAR].y + landmarks[mp.PoseLandmark.RIGHT_EAR].y) / 2
        )
        shoulder_center = (
            (landmarks[mp.PoseLandmark.LEFT_SHOULDER].x + landmarks[mp.PoseLandmark.RIGHT_SHOULDER].x) / 2,
            (landmarks[mp.PoseLandmark.LEFT_SHOULDER].y + landmarks[mp.PoseLandmark.RIGHT_SHOULDER].y) / 2
        )
        vertical_deviation = abs(neck_top[0] - shoulder_center[0])
        return {
            'neck_angle': neck_angle,
            'grade': grade,
            'grade_description': desc,
            'vertical_deviation': vertical_deviation,
            'neck_top': neck_top,
            'shoulder_center': shoulder_center
        }

    def analyze_spine_curvature(self, landmarks):
        """Ï≤ôÏ∂î Íµ¥Í≥° Î∂ÑÏÑù"""
        left_shoulder = landmarks[self.mp_pose.PoseLandmark.LEFT_SHOULDER]
        right_shoulder = landmarks[self.mp_pose.PoseLandmark.RIGHT_SHOULDER]
        left_hip = landmarks[self.mp_pose.PoseLandmark.LEFT_HIP]
        right_hip = landmarks[self.mp_pose.PoseLandmark.RIGHT_HIP]
        
        # Ïñ¥Íπ®ÏôÄ ÏóâÎç©Ïù¥ Ï§ëÏã¨Ï†ê
        shoulder_center_x = (left_shoulder.x + right_shoulder.x) / 2
        shoulder_center_y = (left_shoulder.y + right_shoulder.y) / 2
        hip_center_x = (left_hip.x + right_hip.x) / 2
        hip_center_y = (left_hip.y + right_hip.y) / 2
        
        # Ï≤ôÏ∂î Í∞ÅÎèÑ Í≥ÑÏÇ∞
        spine_angle = math.degrees(math.atan2(hip_center_x - shoulder_center_x, 
                                            hip_center_y - shoulder_center_y))
        
        # Ï≤ôÏ∂î Íµ¥Í≥° ÌåêÏ†ï
        is_hunched = abs(spine_angle) > 12
        
        return {
            'is_hunched': is_hunched,
            'spine_angle': spine_angle,
            'shoulder_center': (shoulder_center_x, shoulder_center_y),
            'hip_center': (hip_center_x, hip_center_y)
        }

    def analyze_shoulder_asymmetry(self, landmarks):
        """Ïñ¥Íπ® ÎπÑÎåÄÏπ≠ Î∂ÑÏÑù"""
        left_shoulder = landmarks[self.mp_pose.PoseLandmark.LEFT_SHOULDER]
        right_shoulder = landmarks[self.mp_pose.PoseLandmark.RIGHT_SHOULDER]
        
        # Ïñ¥Íπ® ÎÜíÏù¥ Ï∞®Ïù¥ Í≥ÑÏÇ∞
        shoulder_height_diff = abs(left_shoulder.y - right_shoulder.y)
        
        # Ïñ¥Íπ® ÎπÑÎåÄÏπ≠ ÌåêÏ†ï
        is_asymmetric = shoulder_height_diff > 0.02
        
        return {
            'is_asymmetric': is_asymmetric,
            'height_difference': shoulder_height_diff,
            'left_shoulder': (left_shoulder.x, left_shoulder.y),
            'right_shoulder': (right_shoulder.x, right_shoulder.y)
        }

    def analyze_pelvic_tilt(self, landmarks):
        """Í≥®Î∞ò Í∏∞Ïö∏Í∏∞ Î∂ÑÏÑù"""
        left_hip = landmarks[self.mp_pose.PoseLandmark.LEFT_HIP]
        right_hip = landmarks[self.mp_pose.PoseLandmark.RIGHT_HIP]
        
        # Í≥®Î∞ò ÎÜíÏù¥ Ï∞®Ïù¥ Í≥ÑÏÇ∞
        hip_height_diff = abs(left_hip.y - right_hip.y)
        
        # Í≥®Î∞ò Í∏∞Ïö∏Ïñ¥Ïßê ÌåêÏ†ï
        is_tilted = hip_height_diff > 0.015
        
        return {
            'is_tilted': is_tilted,
            'height_difference': hip_height_diff,
            'left_hip': (left_hip.x, left_hip.y),
            'right_hip': (right_hip.x, right_hip.y)
        }

# PostureAnalyzer Ïù∏Ïä§ÌÑ¥Ïä§ ÏÉùÏÑ±
posture_analyzer = PostureAnalyzer()

def analyze_posture(landmarks):
    """ÏôÑÏ†ÑÌïú ÏûêÏÑ∏ Î∂ÑÏÑù (Flask Î≤ÑÏ†ÑÍ≥º ÎèôÏùº)"""
    if not landmarks:
        return {
            'overall_score': 50,
            'overall_grade': 'C',
            'neck': {'angle': None, 'grade': 'C', 'description': 'ÏûêÏÑ∏ Í∞êÏßÄ ÏïàÎê®'},
            'spine': {'is_hunched': False},
            'shoulder': {'is_asymmetric': False},
            'pelvic': {'is_tilted': False}
        }
    
    # Í∞Å Î∂ÄÏúÑÎ≥Ñ Î∂ÑÏÑù
    neck_result = posture_analyzer.analyze_turtle_neck_detailed(landmarks)
    spine_result = posture_analyzer.analyze_spine_curvature(landmarks)
    shoulder_result = posture_analyzer.analyze_shoulder_asymmetry(landmarks)
    pelvic_result = posture_analyzer.analyze_pelvic_tilt(landmarks)
    
    # Ï¢ÖÌï© Ï†êÏàò Í≥ÑÏÇ∞ (FlaskÏôÄ ÎèôÏùºÌïú Î°úÏßÅ)
    score = 100
    
    # Î™© ÏûêÏÑ∏ Ï†êÏàò (30Ï†ê)
    if neck_result['grade'] == 'A':
        score -= 0
    elif neck_result['grade'] == 'B':
        score -= 10
    elif neck_result['grade'] == 'C':
        score -= 20
    else:  # D
        score -= 30
    
    # Ï≤ôÏ∂î Í≥°Î•† Ï†êÏàò (25Ï†ê)
    if spine_result['is_hunched']:
        score -= 25
    
    # Ïñ¥Íπ® ÎπÑÎåÄÏπ≠ Ï†êÏàò (20Ï†ê)
    if shoulder_result['is_asymmetric']:
        score -= 20
    
    # Í≥®Î∞ò Í∏∞Ïö∏Í∏∞ Ï†êÏàò (15Ï†ê)
    if pelvic_result['is_tilted']:
        score -= 15
    
    score = max(0, score)
    
    # Ï¢ÖÌï© Îì±Í∏â
    if score >= 90:
        overall_grade = 'A'
    elif score >= 70:
        overall_grade = 'B'
    else:
        overall_grade = 'C'
    
    return {
        'overall_score': score,
        'overall_grade': overall_grade,
        'neck': neck_result,
        'spine': spine_result,
        'shoulder': shoulder_result,
        'pelvic': pelvic_result
    }

# Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ï†ÄÏû•
def save_posture_data(analysis_result):
    try:
        conn = sqlite3.connect('local.sqlite')
        cursor = conn.cursor()
        cursor.execute('''
            INSERT INTO posture_data 
            (overall_score, overall_grade, neck_angle, neck_grade)
            VALUES (?, ?, ?, ?)
        ''', (
            analysis_result['overall_score'],
            analysis_result['overall_grade'],
            analysis_result['neck_angle'],
            analysis_result['neck_grade']
        ))
        conn.commit()
        conn.close()
        logger.info("Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ï†ÄÏû• ÏÑ±Í≥µ")
        return True
    except Exception as e:
        logger.error(f"Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ï†ÄÏû• Ïã§Ìå®: {e}")
        return False

# ÎùºÏö∞Ìä∏ Ï†ïÏùò
@app.get("/", response_class=HTMLResponse)
async def root(request: Request):
    try:
        return templates.TemplateResponse("crud/index.html", {"request": request})
    except Exception as e:
        return HTMLResponse(f"""
        <html>
        <head><title>FastAPI ÌÜµÌï© ÏÑúÎ≤Ñ</title></head>
        <body>
            <h1>üöÄ FastAPI ÌÜµÌï© ÏÑúÎ≤ÑÍ∞Ä Ïã§Ìñâ Ï§ëÏûÖÎãàÎã§!</h1>
            <p>üì° ESP32-CAM IP: {ESP32_IP}</p>
            <p>üåê ÏÑúÎ≤Ñ Ï£ºÏÜå: http://localhost:8000</p>
            <p>‚úÖ ESP32 Ïó∞Í≤∞ ÏÉÅÌÉú: {'Ïó∞Í≤∞Îê®' if check_esp32_connection() else 'Ïó∞Í≤∞ÎêòÏßÄ ÏïäÏùå'}</p>
            <hr>
            <p><a href="/crud/">ÏûêÏÑ∏ Î∂ÑÏÑù ÌéòÏù¥ÏßÄÎ°ú Ïù¥Îèô</a></p>
            <p><a href="/crud/buzzer-test">Î∂ÄÏ†Ä ÌÖåÏä§Ìä∏</a></p>
            <p><strong>Ïò§Î•ò Ï†ïÎ≥¥:</strong> {str(e)}</p>
        </body>
        </html>
        """)

@app.get("/auth/login", response_class=HTMLResponse, name="auth.login")
async def login_page(request: Request):
    return templates.TemplateResponse("crud/login.html", {"request": request})

@app.post("/auth/login")
async def login(request: Request):
    return JSONResponse({"success": True})

@app.get("/auth/register", response_class=HTMLResponse, name="auth.register")
async def register_page(request: Request):
    return templates.TemplateResponse("crud/register.html", {"request": request})

@app.get("/auth/logout", response_class=HTMLResponse, name="auth.logout")
async def logout_page(request: Request):
    # Ïã§Ï†ú Î°úÍ∑∏ÏïÑÏõÉ Ï≤òÎ¶¨Îäî Ï∂îÌõÑ Íµ¨ÌòÑ
    return templates.TemplateResponse("crud/login.html", {"request": request})

@app.get("/crud/", response_class=HTMLResponse, name="crud.index")
async def crud_index(request: Request):
    return templates.TemplateResponse("crud/index.html", {"request": request, "user": None})

@app.get("/esp32-stream")
async def esp32_stream():
    def generate():
        max_retries = 3
        retry_count = 0
        
        while retry_count < max_retries:
            try:
                logger.info(f"ESP32 Ïä§Ìä∏Î¶º Ïó∞Í≤∞ ÏãúÎèÑ {retry_count + 1}/{max_retries}")
                response = requests.get(f"{ESP32_STREAM_URL}/stream", stream=True, timeout=10)
                
                if response.status_code == 200:
                    logger.info("ESP32 Ïä§Ìä∏Î¶º Ïó∞Í≤∞ ÏÑ±Í≥µ")
                    stream_manager.stream_active = True
                    
                    content = b""
                    for chunk in response.iter_content(chunk_size=1024):
                        if chunk:
                            content += chunk
                            yield chunk
                            
                            # ÌîÑÎ†àÏûÑ Ï∂îÏ∂ú Î∞è Ï†ÄÏû• (Î∂ÑÏÑùÏö©)
                            start_pos = content.find(b'\xff\xd8')
                            if start_pos != -1:
                                end_pos = content.find(b'\xff\xd9', start_pos)
                                if end_pos != -1:
                                    jpeg_data = content[start_pos:end_pos + 2]
                                    image_array = np.frombuffer(jpeg_data, dtype=np.uint8)
                                    frame = cv2.imdecode(image_array, cv2.IMREAD_COLOR)
                                    if frame is not None:
                                        stream_manager.update_frame(frame)
                                    content = content[end_pos + 2:]  # Ï≤òÎ¶¨Îêú ÌîÑÎ†àÏûÑ Ï†úÍ±∞
                    
                    break  # ÏÑ±Í≥µÌïòÎ©¥ Î£®ÌîÑ Ï¢ÖÎ£å
                else:
                    logger.error(f"ESP32 Ïä§Ìä∏Î¶º Ïó∞Í≤∞ Ïã§Ìå®: {response.status_code}")
                    retry_count += 1
                    if retry_count < max_retries:
                        time.sleep(2)  # 2Ï¥à ÎåÄÍ∏∞ ÌõÑ Ïû¨ÏãúÎèÑ
                        
            except Exception as e:
                logger.error(f"ESP32 Ïä§Ìä∏Î¶º Ïò§Î•ò (ÏãúÎèÑ {retry_count + 1}): {e}")
                retry_count += 1
                if retry_count < max_retries:
                    time.sleep(2)  # 2Ï¥à ÎåÄÍ∏∞ ÌõÑ Ïû¨ÏãúÎèÑ
        
        if retry_count >= max_retries:
            logger.error("ESP32 Ïä§Ìä∏Î¶º Ïó∞Í≤∞ ÏµúÎåÄ Ïû¨ÏãúÎèÑ ÌöüÏàò Ï¥àÍ≥º")
            stream_manager.stream_active = False
            # ÏóêÎü¨ Ïù¥ÎØ∏ÏßÄÎÇò Î©îÏãúÏßÄ Î∞òÌôò
            yield b"--frame\r\nContent-Type: image/jpeg\r\nContent-Length: 0\r\n\r\n"
    
    return StreamingResponse(
        generate(),
        media_type="multipart/x-mixed-replace; boundary=frame"
    )

@app.get("/esp32-stream-analyze")
async def esp32_stream_with_analysis():
    """Ïã§ÏãúÍ∞Ñ Ïä§Ìä∏Î¶º (ÌîÑÎ†àÏûÑ Ï†ÄÏû• Ìè¨Ìï®)"""
    def generate():
        max_retries = 3
        retry_count = 0
        
        while retry_count < max_retries:
            try:
                logger.info(f"ESP32 Î∂ÑÏÑù Ïä§Ìä∏Î¶º Ïó∞Í≤∞ ÏãúÎèÑ {retry_count + 1}/{max_retries}")
                response = requests.get(f"{ESP32_STREAM_URL}/stream", stream=True, timeout=10)
                
                if response.status_code == 200:
                    logger.info("ESP32 Î∂ÑÏÑù Ïä§Ìä∏Î¶º Ïó∞Í≤∞ ÏÑ±Í≥µ")
                    stream_manager.stream_active = True
                    
                    content = b""
                    for chunk in response.iter_content(chunk_size=1024):
                        if chunk:
                            content += chunk
                            yield chunk
                            # MJPEG Ïä§Ìä∏Î¶ºÏóêÏÑú JPEG ÌîÑÎ†àÏûÑ Ï∂îÏ∂ú Î∞è Ï†ÄÏû•
                            while True:
                                start = content.find(b'\xff\xd8')
                                end = content.find(b'\xff\xd9', start)
                                if start != -1 and end != -1:
                                    jpeg = content[start:end+2]
                                    image_array = np.frombuffer(jpeg, dtype=np.uint8)
                                    frame = cv2.imdecode(image_array, cv2.IMREAD_COLOR)
                                    if frame is not None:
                                        stream_manager.update_frame(frame)
                                    content = content[end+2:]
                                else:
                                    break
                    
                    break  # ÏÑ±Í≥µÌïòÎ©¥ Î£®ÌîÑ Ï¢ÖÎ£å
                else:
                    logger.error(f"ESP32 Î∂ÑÏÑù Ïä§Ìä∏Î¶º Ïó∞Í≤∞ Ïã§Ìå®: {response.status_code}")
                    retry_count += 1
                    if retry_count < max_retries:
                        time.sleep(2)  # 2Ï¥à ÎåÄÍ∏∞ ÌõÑ Ïû¨ÏãúÎèÑ
                        
            except Exception as e:
                logger.error(f"ESP32 Î∂ÑÏÑù Ïä§Ìä∏Î¶º Ïò§Î•ò (ÏãúÎèÑ {retry_count + 1}): {e}")
                retry_count += 1
                if retry_count < max_retries:
                    time.sleep(2)  # 2Ï¥à ÎåÄÍ∏∞ ÌõÑ Ïû¨ÏãúÎèÑ
        
        if retry_count >= max_retries:
            logger.error("ESP32 Î∂ÑÏÑù Ïä§Ìä∏Î¶º Ïó∞Í≤∞ ÏµúÎåÄ Ïû¨ÏãúÎèÑ ÌöüÏàò Ï¥àÍ≥º")
            stream_manager.stream_active = False
            # ÏóêÎü¨ Ïù¥ÎØ∏ÏßÄÎÇò Î©îÏãúÏßÄ Î∞òÌôò
            yield b"--frame\r\nContent-Type: image/jpeg\r\nContent-Length: 0\r\n\r\n"
    
    return StreamingResponse(
        generate(),
        media_type="multipart/x-mixed-replace; boundary=frame"
    )

# ÏöîÏ≤≠ Î™®Îç∏ Ï∂îÍ∞Ä
class AnalyzeRequest(BaseModel):
    capture_frame: bool = True

@app.post("/crud/analyze")
async def analyze_posture_endpoint(request: Request):
    """Ïã§ÏãúÍ∞Ñ Î∂ÑÏÑù (Ï†ÄÏû•Îêú ÌîÑÎ†àÏûÑ ÏÇ¨Ïö©)"""
    try:
        # Ïä§Ìä∏Î¶º Îß§ÎãàÏ†ÄÏóêÏÑú ÏµúÏã† ÌîÑÎ†àÏûÑ Í∞ÄÏ†∏Ïò§Í∏∞
        if not stream_manager.is_stream_active():
            return JSONResponse({
                "error": "ESP32-CAM Ïä§Ìä∏Î¶ºÏù¥ ÌôúÏÑ±ÌôîÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§",
                "state": "error"
            })
        
        image = stream_manager.get_frame()
        if image is None:
            return JSONResponse({
                "error": "Ïú†Ìö®Ìïú ÌîÑÎ†àÏûÑÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§",
                "state": "error"
            })
        
        # MediaPipe Î∂ÑÏÑù
        image_rgb = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
        results = pose.process(image_rgb)
        
        # ÏûêÏÑ∏ Î∂ÑÏÑù (ÏûêÏÑ∏ Í∞êÏßÄ ÏïàÎê®ÎèÑ CÎì±Í∏âÏúºÎ°ú Ï≤òÎ¶¨)
        if results.pose_landmarks:
            landmarks = results.pose_landmarks.landmark
            analysis_result = analyze_posture(landmarks)
        else:
            # ÏûêÏÑ∏ Í∞êÏßÄ ÏïàÎê® ‚Üí CÎì±Í∏âÏúºÎ°ú Ï≤òÎ¶¨
            analysis_result = analyze_posture(None)
        
        if not analysis_result:
            return JSONResponse({
                "error": "ÏûêÏÑ∏ Î∂ÑÏÑùÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§",
                "state": "analysis_failed"
            })
        
        # Ïó∞ÏÜç ÏûêÏÑ∏ Ïπ¥Ïö¥ÌÑ∞ ÏóÖÎç∞Ïù¥Ìä∏
        grade = analysis_result['overall_grade']
        current_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        
        for g in ['A', 'B', 'C']:
            if g == grade:
                posture_counter[g] += 1
            else:
                posture_counter[g] = 0
        
        # Î∂ÄÏ†Ä Ìä∏Î¶¨Í±∞ Î°úÏßÅ
        buzzer_triggered = False
        
        # BÎì±Í∏â 30Î≤à Ïó∞ÏÜç ‚Üí Î∂ÄÏ†Ä 1Î≤à
        if posture_counter['B'] == 30:
            buzzer_status = get_buzzer_status()
            volume = 50  # Í∏∞Î≥∏Í∞í
            if buzzer_status and 'volume' in buzzer_status:
                volume = buzzer_status['volume']
            
            logger.info(f"[{current_time}] üö® BÎì±Í∏â 30Î≤à Ïó∞ÏÜç! Î∂ÄÏ†Ä 1Î≤à Ïö∏Î¶º (Î≥ºÎ•®: {volume}%)")
            trigger_buzzer(duration_ms=1000, volume=volume)
            posture_counter['B'] = 0  # Ïπ¥Ïö¥ÌÑ∞ Î¶¨ÏÖã
            buzzer_triggered = True
        
        # CÎì±Í∏â 30Î≤à Ïó∞ÏÜç ‚Üí Î∂ÄÏ†Ä 2Î≤à
        elif posture_counter['C'] == 30:
            buzzer_status = get_buzzer_status()
            volume = 50  # Í∏∞Î≥∏Í∞í
            if buzzer_status and 'volume' in buzzer_status:
                volume = buzzer_status['volume']
            
            logger.info(f"[{current_time}] üö® CÎì±Í∏â 30Î≤à Ïó∞ÏÜç! Î∂ÄÏ†Ä 2Î≤à Ïö∏Î¶º (Î≥ºÎ•®: {volume}%)")
            # Î∂ÄÏ†Ä 2Î≤à Ïó∞ÏÜç Ïö∏Î¶º
            trigger_buzzer(duration_ms=1000, volume=volume)
            time.sleep(0.1)  # 0.1Ï¥à Í∞ÑÍ≤©
            trigger_buzzer(duration_ms=1000, volume=volume)
            posture_counter['C'] = 0  # Ïπ¥Ïö¥ÌÑ∞ Î¶¨ÏÖã
            buzzer_triggered = True
        
        # Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§Ïóê Ï†ÄÏû•
        save_posture_data(analysis_result)
        
        # ÏùëÎãµ Îç∞Ïù¥ÌÑ∞ Íµ¨ÏÑ±
        response_data = {
            "overall_score": analysis_result['overall_score'],
            "overall_grade": analysis_result['overall_grade'],
            "neck": analysis_result.get('neck', {}),
            "spine": analysis_result.get('spine', {}),
            "shoulder": analysis_result.get('shoulder', {}),
            "pelvic": analysis_result.get('pelvic', {}),
            "buzzer_triggered": buzzer_triggered,
            "state": "analyzed",
            "state_message": f"Î∂ÑÏÑù ÏôÑÎ£å: {analysis_result['overall_score']}Ï†ê ({grade}Îì±Í∏â)",
            "timestamp": current_time
        }
        
        logger.info(f"[{current_time}] Î∂ÑÏÑù ÏôÑÎ£å: {analysis_result['overall_score']}Ï†ê ({grade}Îì±Í∏â) - Ïó∞ÏÜç: A({posture_counter['A']}) B({posture_counter['B']}) C({posture_counter['C']})")
        
        return JSONResponse(response_data)
        
    except Exception as e:
        logger.error(f"Î∂ÑÏÑù ÏóîÎìúÌè¨Ïù∏Ìä∏ Ïò§Î•ò: {e}")
        return JSONResponse({
            "error": f"Î∂ÑÏÑù Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§: {str(e)}",
            "state": "error"
        })

@app.get("/crud/statistics", response_class=HTMLResponse, name="crud.statistics")
async def statistics_page(request: Request):
    return templates.TemplateResponse("crud/statistics.html", {"request": request, "user": None, "total_records": 0, "avg_score": 0, "grade_counts": {"A":0, "B":0, "C":0, "D":0}})

@app.get("/crud/history", response_class=HTMLResponse, name="crud.history")
async def history_page(request: Request):
    return templates.TemplateResponse("crud/history.html", {"request": request, "user": None, "records": {"items": [], "pages": 1, "page": 1, "has_prev": False, "has_next": False, "prev_num": 1, "next_num": 1}})

@app.get("/crud/profile", response_class=HTMLResponse, name="auth.profile")
async def profile_page(request: Request):
    return templates.TemplateResponse("crud/profile.html", {"request": request, "user": None, "total_analyses": 0, "avg_score": 0, "grade_counts": {"A":0, "B":0, "C":0, "D":0}, "recent_records": []})

@app.get("/crud/buzzer-test", response_class=HTMLResponse, name="crud.buzzer_test")
async def buzzer_test_page(request: Request):
    return templates.TemplateResponse("crud/buzzer_test.html", {"request": request})

# ESP8266 Buzzer Control API ÏóîÎìúÌè¨Ïù∏Ìä∏Îì§
class VolumeRequest(BaseModel):
    volume: int

class TriggerRequest(BaseModel):
    duration: int = 1000
    volume: int = 50

@app.post("/api/buzzer/trigger")
async def api_trigger_buzzer(req: TriggerRequest):
    """APIÎ•º ÌÜµÌï¥ buzzer Ìä∏Î¶¨Í±∞"""
    success = trigger_buzzer(duration_ms=req.duration, volume=req.volume)
    return JSONResponse({
        "success": success,
        "message": "Buzzer triggered" if success else "Failed to trigger buzzer"
    })

@app.post("/api/buzzer/volume")
async def api_set_buzzer_volume(req: VolumeRequest):
    volume = req.volume
    if not 0 <= volume <= 100:
        raise HTTPException(status_code=400, detail="Volume must be between 0 and 100")
    
    success = set_buzzer_volume(volume)
    return JSONResponse({
        "success": success,
        "message": f"Volume set to {volume}" if success else "Failed to set volume"
    })

@app.get("/api/buzzer/status")
async def api_get_buzzer_status():
    """APIÎ•º ÌÜµÌï¥ buzzer ÏÉÅÌÉú ÌôïÏù∏"""
    status = get_buzzer_status()
    connection_status = check_esp8266_connection()
    
    return JSONResponse({
        "connected": connection_status,
        "status": status,
        "esp8266_ip": ESP8266_IP
    })

@app.get("/api/buzzer/test")
async def api_test_buzzer():
    """APIÎ•º ÌÜµÌï¥ buzzer ÌÖåÏä§Ìä∏ (ÏßßÏùÄ ÎπÑÌîÑÏùå) - ÌòÑÏû¨ ÏÑ§Ï†ïÎêú Î≥ºÎ•® ÏÇ¨Ïö©"""
    # ESP8266ÏóêÏÑú ÌòÑÏû¨ Î≥ºÎ•® ÏÉÅÌÉú Í∞ÄÏ†∏Ïò§Í∏∞
    status = get_buzzer_status()
    current_volume = 50  # Í∏∞Î≥∏Í∞í
    
    if status and 'volume' in status:
        current_volume = status['volume']
    
    success = trigger_buzzer(duration_ms=500, volume=current_volume)
    return JSONResponse({
        "success": success,
        "message": f"Test beep sent with volume {current_volume}%" if success else "Failed to send test beep"
    })

@app.on_event("startup")
async def startup_event():
    init_db()
    logger.info("üöÄ FastAPI ÌÜµÌï© ÏÑúÎ≤Ñ ÏãúÏûë")
    logger.info(f"üì° ESP32-CAM IP Ï£ºÏÜå: {ESP32_IP}")
    logger.info("üåê Î∏åÎùºÏö∞Ï†ÄÏóêÏÑú http://localhost:8000 Ï†ëÏÜç")

if __name__ == "__main__":
    uvicorn.run(
        "fastapi_integrated_server:app",
        host="0.0.0.0",
        port=8000,
        reload=True
    ) 